#!/usr/bin/perl -w

use strict;

use XML::Parser::PerlSAX;
use IO::File;
use Data::Dumper;
use POSIX qw(ctime);

my $rules = new Rules();
my $parser = new XML::Parser::PerlSAX(Handler => $rules);

use WAP::wbxml;
my $path = $INC{'WAP/wbxml.pm'};
$path =~ s/wbxml\.pm$//i;
my $infile = $path . 'wbrules.xml';
my $io = new IO::File($infile,"r");
die "Can't open $infile ($!).\n"
		unless (defined $io);

$parser->parse(Source => {ByteStream => $io});
delete $rules->{app_curr};

my $d = Data::Dumper->new([$rules], [qw(rules)]);
#$d->Indent(1);
$d->Indent(0);
my $outfile = "wbrules.pl";
open OUT,"> $outfile"
		or die "Can't open $outfile ($!).\n";
print OUT "# This file is generated by mkwbrules. DO NOT modify it.\n";
print OUT "# From file : ",$infile,"\n";
print OUT "# Generation date : ",POSIX::ctime(time());
print OUT $d->Dump();
close OUT;

=pod

This script `mkwbrules' builds the file `wbrules.pl' from the installed file
`WAP/wbrules.xml' that describes rules of the binarization (module WAP::wbxml).

=cut

package Rules;		# SAX handler

sub new {
	my $class = shift;
	my $self = {};
	bless($self,$class);
	return $self;
}

sub start_element {
	my $self = shift;
	my ($element) = @_;

	my $name = $element->{Name};
	my $attrs = $element->{Attributes};
	if ($name eq 'wbxml:CharacterSet') {
		# <!ELEMENT wbxml:CharacterSet EMPTY>
		# <!ATTLIST wbxml:CharacterSet MIBenum NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:CharacterSet name NMTOKEN #REQUIRED>
		$self->{CharacterSet}{$attrs->{MIBenum}} = $attrs->{name};
	} elsif ($name eq 'wbxml:PublicIdentifier') {
		# <!ELEMENT wbxml:PublicIdentifier EMPTY>
		# <!ATTLIST wbxml:PublicIdentifier value NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:PublicIdentifier name CDATA #REQUIRED>
		$self->{PublicIdentifier}{hex $attrs->{value}} = $attrs->{name};
	} elsif ($name eq 'wbxml:App') {
		# <!ELEMENT wbxml:App (wbxml:TagTokens,wbxml:AttrStartTokens,wbxml:AttrValueTokens)>
		# <!ATTLIST wbxml:App publicid CDATA #REQUIRED>
		# <!ATTLIST wbxml:App use-default (no|yes) #IMPLIED>
		# <!ATTLIST wbxml:App variable-subs (no|yes) #IMPLIED>
		# <!ATTLIST wbxml:App textual-ext NMTOKEN #IMPLIED>
		# <!ATTLIST wbxml:App tokenised-ext NMTOKEN #IMPLIED>
		# <!ATTLIST wbxml:App xml-space (default|preserve) #IMPLIED>
		my $publicid = $attrs->{publicid};
		$self->{app_curr} = $publicid;
		$self->{App}{$publicid} = bless({},'App');
		$self->{App}{$publicid}->{variable_subs} = $attrs->{'variable-subs'}
				if (	    exists $attrs->{'variable-subs'}
						and $attrs->{'variable-subs'} eq 'yes' );
	} elsif ($name eq 'wbxml:TAG') {
		# <!ELEMENT wbxml:TAG EMPTY>
		# <!ATTLIST wbxml:TAG token NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:TAG name NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:TAG codepage NMTOKEN #IMPLIED>
		my $token = hex $attrs->{token};
		$token += 256 * hex $attrs->{codepage}
				if (exists $attrs->{codepage});
		$self->{App}{$self->{app_curr}}->{TAG}{$token} = $attrs->{name};
	} elsif ($name eq 'wbxml:ATTRSTART') {
		# <!ELEMENT wbxml:ATTRSTART EMPTY>
		# <!ATTLIST wbxml:ATTRSTART token NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:ATTRSTART name NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:ATTRSTART value CDATA #IMPLIED>
		# <!ATTLIST wbxml:ATTRSTART codepage NMTOKEN #IMPLIED>
		# <!ATTLIST wbxml:ATTRSTART default CDATA #IMPLIED>
		# <!ATTLIST wbxml:ATTRSTART fixed CDATA #IMPLIED>
		# <!ATTLIST wbxml:ATTRSTART validate (std|length|vdata) #IMPLIED>
		# <!ATTLIST wbxml:ATTRSTART encoding (std|iso-8601) #IMPLIED>
		my $token = hex $attrs->{token};
		$token += 256 * hex $attrs->{codepage}
				if (exists $attrs->{codepage});
		$self->{App}{$self->{app_curr}}->{ATTRSTART}{$token} = {};
		$self->{App}{$self->{app_curr}}->{ATTRSTART}{$token}{name} = $attrs->{name};
		$self->{App}{$self->{app_curr}}->{ATTRSTART}{$token}{value} = $attrs->{value}
				if (exists $attrs->{value});
		$self->{App}{$self->{app_curr}}->{ATTRSTART}{$token}{validate} = $attrs->{validate}
				if (exists $attrs->{validate});
		$self->{App}{$self->{app_curr}}->{ATTRSTART}{$token}{encoding} = $attrs->{encoding}
				if (exists $attrs->{encoding});
	} elsif ($name eq 'wbxml:ATTRVALUE') {
		# <!ELEMENT wbxml:ATTRVALUE EMPTY>
		# <!ATTLIST wbxml:ATTRVALUE token NMTOKEN #REQUIRED>
		# <!ATTLIST wbxml:ATTRVALUE value CDATA #REQUIRED>
		# <!ATTLIST wbxml:ATTRVALUE codepage NMTOKEN #IMPLIED>
		my $token = hex $attrs->{token};
		$token += 256 * hex $attrs->{codepage}
				if (exists $attrs->{codepage});
		$self->{App}{$self->{app_curr}}->{ATTRVALUE}{$token} = $attrs->{value};
	}

}

